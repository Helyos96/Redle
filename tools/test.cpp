#include <cryptopp/integer.h>
#include <cryptopp/dh.h>
#include <cryptopp/dh2.h>
#include <cryptopp/osrng.h>
#include <cryptopp/nbtheory.h>
#include <cryptopp/files.h>
#include <iostream>

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>

using namespace std;
using namespace CryptoPP;

void print_bin(const unsigned char *ptr, size_t len) {
	printf("{");
	for (size_t i = 0; i < len; ++i) {
		printf("0x%02X", ptr[i]);
		if (i != len-1)
			printf(", ");
	}
	printf("}\n");
}

const unsigned char client_dh_static_priv[] =
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x0A, 0x40, 0x0F, 0x5D, 0x71, 0xDE, 0xFF, 0x86, 0xAC, 0x2F, 
  0x7E, 0x2B, 0xD1, 0xB4, 0x1A, 0xB1, 0xEB, 0x10, 0x0C, 0xDE, 
  0x79, 0xEC, 0xD9, 0xE8, 0x33, 0xA2, 0x26, 0x86, 0xAB, 0x49, 
  0x6B, 0xE0, 0x9D, 0x3A
};

int main() {
	Integer p_eph("0xc5d1fff6e1e0b5b5a4220a369a4f504d59c7482724053c0d4b05426328031633bc79249c1c58c91b32e6802f20a1e7626859da201e7faad8406c702796cbdf3208a6cccb77baa29bec763a9a1fb868d79182f00957e890d762806b443e7fd2f75ef2eed5f56e92e5939ec15533a642b2212504b62ba72ca8e6c7fe28bbc8f687");
	Integer g_eph("0x2");
	Integer q_eph("0x62e8fffb70f05adad211051b4d27a826ace3a41392029e06a582a13194018b19de3c924e0e2c648d997340179050f3b1342ced100f3fd56c20363813cb65ef9904536665bbdd514df63b1d4d0fdc346bc8c17804abf4486bb14035a21f3fe97baf79776afab74972c9cf60aa99d321591092825b15d396547363ff145de47b43");

	Integer p_sta("0xcd8fd4b7415dee60366c437dc8b43cfb01e35540cdd79b22f60b6c6ad4c77571efc441a88c33e8bacaa6bcca3e5099d58a8415b35217a5119b4eb3893f1472b9ed168230c3ca982f32202658f88959881c1bdd98423af79caca5d517544f09214e4ff3d2e6108fa21776749af68282771799575269507bc69b20b66eb74d075e57a5b96c13180262b2a96ea3c42e128bcc064f5b4e7a451f12f074bd2e64d433ab380494ed53d1c45db97cc4b3da288bf3533499a5f607b55175cc1d7ef917459e8f77658638d918e23753cf29429b846dcd410e541a855ebb4d04d065627b0025bb37a2a75733c65bf9d0a9e4aeabcb07eea223e6aa9c084b86e1c100c83af11bdba33ac34e80afaee202ff8511f4451b48e91490d773816eff332e8db21bbe3e8bf30d0b4408bbe32b5db2695b413e1f87101ebc547446f01ec77105de81db454ad676e3401add8471a432da342518e0497df6db7e59cb09bf3accb685617695d07cff6a875de4bec17368509d02ade555a92dd4abdaf6c44300536cadddab");
	Integer g_sta("0x3");
	Integer q_sta("0x66c7ea5ba0aef7301b3621bee45a1e7d80f1aaa066ebcd917b05b6356a63bab8f7e220d44619f45d65535e651f284ceac5420ad9a90bd288cda759c49f8a395cf68b411861e54c179910132c7c44acc40e0deecc211d7bce5652ea8baa278490a727f9e9730847d10bbb3a4d7b41413b8bccaba934a83de34d905b375ba683af2bd2dcb6098c01315954b751e2170945e60327ada73d228f89783a5e97326a19d59c024a76a9e8e22edcbe6259ed1445f9a99a4cd2fb03daa8bae60ebf7c8ba2cf47bbb2c31c6c8c711ba9e794a14dc236e6a0872a0d42af5da6826832b13d8012dd9bd153ab99e32dfce854f25755e583f75111f3554e0425c370e080641d788dedd19d61a74057d771017fc288fa228da4748a486bb9c0b77f999746d90ddf1f45f98685a2045df195aed934ada09f0fc3880f5e2a3a23780f63b882ef40eda2a56b3b71a00d6ec238d2196d1a128c7024befb6dbf2ce584df9d665b42b0bb4ae83e7fb543aef25f60b9b4284e8156f2aad496ea55ed7b62218029b656eed5");

	AutoSeededRandomPool rnd;

	// DH Init
	DH dh_eph, dh_sta;
	dh_eph.AccessGroupParameters().Initialize(p_eph, q_eph, g_eph);
	dh_sta.AccessGroupParameters().Initialize(p_sta, q_sta, g_sta);

	if(!dh_eph.GetGroupParameters().ValidateGroup(rnd, 3)) {
		printf("Failed to validate Ephemeral prime and generator\n");
		throw runtime_error("Failed to validate prime and generator");
	}
	
	if(!dh_sta.GetGroupParameters().ValidateGroup(rnd, 3)) {
		printf("Failed to validate Static prime and generator\n");
		throw runtime_error("Failed to validate prime and generator");
	}
	
	Integer v = ModularExponentiation(g_eph, q_eph, p_eph);
	if(v != Integer::One()) {
		printf("Failed to verify order of the Ephemeral subgroup\n");
		throw runtime_error("Failed to verify order of the subgroup");
	}
	
	v = ModularExponentiation(g_sta, q_sta, p_sta);
	if(v != Integer::One()) {
		printf("Failed to verify order of the Static subgroup\n");
		throw runtime_error("Failed to verify order of the subgroup");
	}

	// Unified Diffie Hellman with different domain parameters for static and ephemeral keys
	DH2 dh(dh_sta, dh_eph);

	printf("key sizes: %u %u %u %u %u\n", dh.StaticPrivateKeyLength(), dh.StaticPublicKeyLength(), dh.EphemeralPrivateKeyLength(), dh.EphemeralPublicKeyLength(), dh.AgreedValueLength());
	SecByteBlock sPrivKey(dh.StaticPrivateKeyLength());
	SecByteBlock sPubKey(dh.StaticPublicKeyLength());
	SecByteBlock ePrivKey(dh.EphemeralPrivateKeyLength());
	SecByteBlock ePubKey(dh.EphemeralPublicKeyLength());
	
	dh.GenerateStaticKeyPair(rnd, sPrivKey, sPubKey);
	print_bin(sPrivKey.BytePtr(), sPrivKey.SizeInBytes());
	print_bin(sPubKey.BytePtr(), sPubKey.SizeInBytes());
	
	SecByteBlock client_priv_key(client_dh_static_priv, sizeof(client_dh_static_priv));
	Integer tmp;
	tmp.Decode(client_priv_key.BytePtr(), client_priv_key.SizeInBytes());
	CryptoPP::Integer publicKey = dh_sta.GetGroupParameters().ExponentiateBase(tmp);
	cout << "Hex: " << std::hex << publicKey << endl;
	SecByteBlock bytes;
	size_t encodedSize = publicKey.MinEncodedSize(Integer::UNSIGNED);
    bytes.resize(encodedSize);
    publicKey.Encode(bytes.BytePtr(), encodedSize, Integer::UNSIGNED);
	print_bin(bytes.BytePtr(), bytes.SizeInBytes());
}
